<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <title>Porównanie benchmarków - wykres radarowy</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: Arial, sans-serif; margin: 1em; max-width: 1000px; }
    canvas { max-width: 600px; margin: 20px auto; display: block; }
    h1 { text-align: center; }
    #file-input { margin: 1em 0; }
  </style>
</head>
<body>
  <h1>Porównanie benchmarków - wykres radarowy</h1>
  <p>Wczytaj pliki CSV wygenerowane przez benchmark, by zobaczyć porównanie na wykresie radarowym.</p>

  <input type="file" id="file-input" accept=".csv" multiple />

  <canvas id="radarChart" aria-label="Wykres radarowy benchmarków" role="img"></canvas>

  <script>
    // Prosty parser CSV, obsługa nagłówków i wartości w cudzysłowach
    function parseCSV(text) {
      const lines = text.trim().split(/\r?\n/);
      const headers = lines[0].split(',');
      return lines.slice(1).map(line => {
        const values = [];
        let val = '', inQuotes = false;
        for(let i=0; i < line.length; i++) {
          const char = line[i];
          if(char === '"' && (i===0 || line[i-1] !== '\\')) {
            inQuotes = !inQuotes;
          } else if(char === ',' && !inQuotes) {
            values.push(val.trim().replace(/^"(.*)"$/, '$1'));
            val = '';
          } else {
            val += char;
          }
        }
        values.push(val.trim().replace(/^"(.*)"$/, '$1'));
        const row = {};
        headers.forEach((h,i) => row[h] = values[i] || '');
        return row;
      });
    }

    // Konwertuj wartość na liczbę (float), lub NaN jeśli nie da się
    function parseNumber(value) {
      if(!value) return NaN;
      // usuń wszystko poza cyframi i kropką
      const num = parseFloat(value.replace(/[^0-9.-]+/g,""));
      return isNaN(num) ? NaN : num;
    }

    // Kolory zestawów danych dla wykresu
    const COLORS = [
      'rgba(255, 99, 132, 0.5)',
      'rgba(54, 162, 235, 0.5)',
      'rgba(255, 206, 86, 0.5)',
      'rgba(75, 192, 192, 0.5)',
      'rgba(153, 102, 255, 0.5)',
      'rgba(255, 159, 64, 0.5)'
    ];

    const BORDER_COLORS = COLORS.map(c => c.replace('0.5', '1'));

    const fileInput = document.getElementById('file-input');
    const ctx = document.getElementById('radarChart').getContext('2d');
    let radarChart = null;

    fileInput.addEventListener('change', () => {
      const files = fileInput.files;
      if(files.length === 0) {
        alert('Proszę wybrać przynajmniej jeden plik CSV.');
        return;
      }

      const allData = [];

      let filesProcessed = 0;

      for(let f=0; f<files.length; f++){
        const reader = new FileReader();
        reader.onload = e => {
          try {
            const csvText = e.target.result;
            const data = parseCSV(csvText);
            allData.push({filename: files[filesProcessed].name, data});
          } catch(err){
            alert(`Błąd podczas parsowania pliku ${files[filesProcessed].name}: ${err.message}`);
          }
          filesProcessed++;
          if(filesProcessed === files.length){
            drawRadarChart(allData);
          }
        };
        reader.readAsText(files[f]);
      }
    });

    // Funkcja tworząca wykres radarowy
    function drawRadarChart(fileDataArray){

      // Wybierz testy do porównania - możesz zmienić listę, np. tylko główne testy CPU/RAM/Storage/GPU
      const testsToInclude = [
        'CPU_total_time',
        'RAM_transfer_rate',
        'Disk_write_speed',
        'GPU_glmark2_score'
      ];

      // Zbierz nazwy systemów/pliki
      const labels = fileDataArray.map(f => f.filename);

      // Dla każdego pliku zbierz wartości testów w ustalonej kolejności
      const datasets = fileDataArray.map( (fileObj, idx) => {
        const d = testsToInclude.map(testName => {
          const rec = fileObj.data.find(r => r.test === testName);
          if(!rec) return NaN;
          // dla czasu CPU i dysku im mniejszy wynik lepszy (np. czas w sekundach)
          // dla transferu RAM i GPU glmark2 im wyższy lepszy
          // dlatego można odpowiednio odwrócić/normalizować, ale na początek bierzemy surowe wartości jako liczby
          return parseNumber(rec.wartosc);
        });

        return {
          label: labels[idx],
          data: d,
          backgroundColor: COLORS[idx % COLORS.length],
          borderColor: BORDER_COLORS[idx % BORDER_COLORS.length],
          borderWidth: 2,
          fill: true,
          spanGaps: true,
          // jeśli brak wartości, wykres pomija punkt
          pointRadius: d.map(v => isNaN(v) ? 0 : 3)
        };
      });

      // Przedstawienie na wykresie wymaga normalizacji - tutaj dla prostoty pomińmy (można dodać później)

      // Dodaj etykiety testów, zastępując podkreślenia spacjami
      const radarLabels = testsToInclude.map(t => t.replace(/_/g,' '));

      if(radarChart){
        radarChart.destroy();
      }

      radarChart = new Chart(ctx, {
        type: 'radar',
        data: {
          labels: radarLabels,
          datasets: datasets
        },
        options: {
          responsive: true,
          plugins: {
            title: {
              display: true,
              text: 'Porównanie benchmarków - wykres radarowy'
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  let val = context.raw;
                  if(isNaN(val)) return 'Brak danych';
                  return val;
                }
              }
            }
          },
          scales: {
            r: {
              angleLines: { display: true },
              suggestedMin: 0,
              // nie ustawiamy suggestedMax – zależy od danych
              beginAtZero: true,
              ticks: { stepSize: 1 },
              pointLabels: { font: { size: 14 } }
            }
          }
        }
      });
    }
  </script>
</body>
</html>
